<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ•ã‚©ãƒ³ãƒˆSVGç”Ÿæˆãƒ„ãƒ¼ãƒ«</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5rem;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .form-group {
            margin-bottom: 25px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4a5568;
        }
        
        input[type="file"], textarea, input[type="number"], input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
            box-sizing: border-box;
        }
        
        input[type="file"]:focus, textarea:focus, input[type="number"]:focus, input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        textarea {
            height: 120px;
            resize: vertical;
            font-family: inherit;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }
        
        button {
            flex: 1;
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .generate-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        
        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }
        
        .generate-btn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .preview-btn {
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
        }
        
        .preview-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(72, 187, 120, 0.3);
        }
        
        .preview-section {
            margin-top: 30px;
            padding: 20px;
            background: #f7fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .preview-section h3 {
            margin-top: 0;
            color: #4a5568;
        }
        
        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            font-weight: 500;
            text-align: center;
        }
        
        .status.success {
            background: #c6f6d5;
            color: #22543d;
            border: 1px solid #9ae6b4;
        }
        
        .status.error {
            background: #fed7d7;
            color: #742a2a;
            border: 1px solid #fc8181;
        }
        
        .status.info {
            background: #bee3f8;
            color: #2a4365;
            border: 1px solid #90cdf4;
        }
        
        .settings-row {
            display: flex;
            gap: 20px;
        }
        
        .settings-row .form-group {
            flex: 1;
        }
        
        @media (max-width: 600px) {
            .settings-row {
                flex-direction: column;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .precision-labels {
                flex-direction: column;
                text-align: center;
                gap: 5px;
            }
        }
        
        .precision-labels {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
            font-size: 12px;
            color: #666;
        }
        
        .precision-left {
            color: #48bb78;
            font-weight: 600;
        }
        
        .precision-right {
            color: #764ba2;
            font-weight: 600;
        }
        
        .precision-center {
            background: #f7fafc;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 500;
            color: #4a5568;
            border: 1px solid #e2e8f0;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            background: transparent;
            border-radius: 5px;
        }
        
        input[type="range"]::-webkit-slider-track {
            background: linear-gradient(to right, #48bb78 0%, #667eea 50%, #764ba2 100%);
            height: 8px;
            border-radius: 5px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: white;
            border: 3px solid #667eea;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        input[type="range"]::-moz-range-track {
            background: linear-gradient(to right, #48bb78 0%, #667eea 50%, #764ba2 100%);
            height: 8px;
            border-radius: 5px;
            border: none;
        }
        
        input[type="range"]::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: white;
            border: 3px solid #667eea;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¨ ãƒ•ã‚©ãƒ³ãƒˆSVGç”Ÿæˆãƒ„ãƒ¼ãƒ«</h1>
        
        <div class="form-group">
            <label for="fontFile">ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ« (.ttf, .otf, .woff, .woff2)</label>
            <input type="file" id="fontFile" accept=".ttf,.otf,.woff,.woff2" required>
        </div>
        
        <div class="form-group">
            <label for="filePrefix">ãƒ•ã‚¡ã‚¤ãƒ«åã®æ¥é ­è¾</label>
            <input type="text" id="filePrefix" placeholder="ä¾‹: icon_, my_logo" value="">
        </div>

        <div class="form-group">
            <label for="outputText">å‡ºåŠ›ã™ã‚‹æ–‡å­—</label>
            <textarea id="outputText" placeholder="ã“ã“ã«æç”»ã—ãŸã„æ–‡å­—ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..." required>Hello World!</textarea>
        </div>
        
        <div class="settings-row">
            <div class="form-group">
                <label for="fontSize">ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º (px)</label>
                <input type="number" id="fontSize" value="48" min="12" max="200">
            </div>
            
            <div class="form-group">
                <label for="fontColor">ãƒ•ã‚©ãƒ³ãƒˆã‚«ãƒ©ãƒ¼</label>
                <input type="color" id="fontColor" value="#333333" style="height: 50px;">
            </div>
        </div>
        
        <div class="form-group">
            <label for="precision">SVGè»½é‡åŒ–ï¼ˆåº§æ¨™ç²¾åº¦ï¼‰</label>
            <input type="range" id="precision" min="0" max="10" value="10" step="1" style="width: 100%; height: 8px; background: linear-gradient(to right, #48bb78 0%, #667eea 50%, #764ba2 100%); border-radius: 5px;">
            <div class="precision-labels">
                <span class="precision-left">ğŸª¶ ã‚ˆã‚Šè»½é‡</span>
                <span class="precision-center" id="precisionValue">å°æ•°ç¬¬10ä½ã¾ã§ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)</span>
                <span class="precision-right">ğŸ¯ ã‚ˆã‚Šå…ƒã«è¿‘ã„</span>
            </div>
        </div>
        
        <div class="button-group">
            <button class="preview-btn" onclick="previewSVG()">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</button>
            <button class="generate-btn" onclick="generateZip()">SVGã‚’ç”Ÿæˆã—ã¦ZIPãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
        </div>
        
        <div id="preview" class="preview-section" style="display: none;">
            <h3>ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h3>
            <div id="previewContent"></div>
        </div>
        
        <div id="status"></div>
    </div>

    <script>
        let loadedFont = null;
        let fontName = '';

        document.getElementById('fontFile').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;

            try {
                showStatus('ãƒ•ã‚©ãƒ³ãƒˆã‚’èª­ã¿è¾¼ã¿ä¸­...', 'info');
                
                const arrayBuffer = await file.arrayBuffer();
                loadedFont = opentype.parse(arrayBuffer);
                fontName = loadedFont.names.fontFamily.en || loadedFont.names.fontFamily[Object.keys(loadedFont.names.fontFamily)[0]];
                
                showStatus(`ãƒ•ã‚©ãƒ³ãƒˆ "${file.name}" ãŒæ­£å¸¸ã«èª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸ`, 'success');
            } catch (error) {
                showStatus(`ãƒ•ã‚©ãƒ³ãƒˆã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, 'error');
                loadedFont = null;
            }
        });

        // ç²¾åº¦ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å€¤ã‚’æ›´æ–°
        document.getElementById('precision').addEventListener('input', function(e) {
            const value = parseInt(e.target.value);
            const precisionValue = document.getElementById('precisionValue');
            
            if (value === 0) {
                precisionValue.textContent = 'æ•´æ•°ã®ã¿ (æœ€è»½é‡)';
            } else if (value === 10) {
                precisionValue.textContent = 'å°æ•°ç¬¬10ä½ã¾ã§ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)';
            } else {
                precisionValue.textContent = `å°æ•°ç¬¬${value}ä½ã¾ã§`;
            }
        });

        function roundToPrecision(num, precision) {
            if (precision === 0) {
                return Math.round(num).toString();
            }
            return Number(num.toFixed(precision)).toString();
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
            
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }

        function createSVGForSingleChar(char, fontSize, color, precision = 10) {
            if (!loadedFont) {
                throw new Error('ãƒ•ã‚©ãƒ³ãƒˆãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
            }

            const scale = fontSize / loadedFont.unitsPerEm;
            const glyph = loadedFont.charToGlyph(char);
            
            if (!glyph || !glyph.path || !glyph.path.commands) {
                return null;
            }

            // ãƒ•ã‚©ãƒ³ãƒˆãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’å–å¾—
            const ascender = (loadedFont.ascender || 0) * scale;
            const descender = (loadedFont.descender || 0) * scale;
            const lineHeight = ascender - descender;

            // ã‚°ãƒªãƒ•ã®å®Ÿéš›ã®å¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ã‚’å–å¾—
            const bbox = glyph.getBoundingBox();
            const glyphMinX = bbox.x1 * scale;
            const glyphMaxX = bbox.x2 * scale;
            const glyphMinY = bbox.y1 * scale;
            const glyphMaxY = bbox.y2 * scale;

            const actualWidth = glyphMaxX - glyphMinX;
            const actualHeight = glyphMaxY - glyphMinY;

            const margin = 2;
            const baselineY = ascender + margin;
            const startX = -glyphMinX + margin;

            const svgWidth = Math.max(actualWidth, fontSize * 0.3) + margin * 2;
            const svgHeight = lineHeight + margin * 2;

            let pathString = '';
            
            // ãƒ‘ã‚¹ã‚³ãƒãƒ³ãƒ‰ã‚’SVGãƒ‘ã‚¹ã«å¤‰æ›ï¼ˆç²¾åº¦èª¿æ•´ä»˜ãï¼‰
            for (const cmd of glyph.path.commands) {
                switch (cmd.type) {
                    case 'M':
                        const mx = roundToPrecision(cmd.x * scale + startX, precision);
                        const my = roundToPrecision(baselineY - cmd.y * scale, precision);
                        pathString += `M${mx},${my}`;
                        break;
                    case 'L':
                        const lx = roundToPrecision(cmd.x * scale + startX, precision);
                        const ly = roundToPrecision(baselineY - cmd.y * scale, precision);
                        pathString += `L${lx},${ly}`;
                        break;
                    case 'C':
                        const cx1 = roundToPrecision(cmd.x1 * scale + startX, precision);
                        const cy1 = roundToPrecision(baselineY - cmd.y1 * scale, precision);
                        const cx2 = roundToPrecision(cmd.x2 * scale + startX, precision);
                        const cy2 = roundToPrecision(baselineY - cmd.y2 * scale, precision);
                        const cx = roundToPrecision(cmd.x * scale + startX, precision);
                        const cy = roundToPrecision(baselineY - cmd.y * scale, precision);
                        pathString += `C${cx1},${cy1} ${cx2},${cy2} ${cx},${cy}`;
                        break;
                    case 'Q':
                        const qx1 = roundToPrecision(cmd.x1 * scale + startX, precision);
                        const qy1 = roundToPrecision(baselineY - cmd.y1 * scale, precision);
                        const qx = roundToPrecision(cmd.x * scale + startX, precision);
                        const qy = roundToPrecision(baselineY - cmd.y * scale, precision);
                        pathString += `Q${qx1},${qy1} ${qx},${qy}`;
                        break;
                    case 'Z':
                        pathString += 'Z';
                        break;
                }
            }

            if (!pathString || pathString === 'Z') {
                return null;
            }

            // SVGã‚µã‚¤ã‚ºã‚‚ç²¾åº¦èª¿æ•´
            const finalWidth = roundToPrecision(svgWidth, precision);
            const finalHeight = roundToPrecision(svgHeight, precision);

            const svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${finalWidth}" height="${finalHeight}" viewBox="0 0 ${finalWidth} ${finalHeight}" xmlns="http://www.w3.org/2000/svg">
  <path d="${pathString}" fill="${color}" fill-rule="evenodd"/>
</svg>`;

            return svgContent;
        }

        function createSVGFromPathsAdvanced(text, fontSize, color) {
            if (!loadedFont) {
                throw new Error('ãƒ•ã‚©ãƒ³ãƒˆãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
            }

            const scale = fontSize / loadedFont.unitsPerEm;
            let currentX = 20;
            const baselineY = fontSize + 20;
            const pathElements = [];

            // ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°æƒ…å ±ã‚’è€ƒæ…®ã—ã¦æ–‡å­—ã‚’é…ç½®
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                
                // æ”¹è¡Œæ–‡å­—ã®å‡¦ç†
                if (char === '\n') {
                    currentX = 20;
                    baselineY += fontSize * 1.2;
                    continue;
                }
                
                const glyph = loadedFont.charToGlyph(char);
                
                if (glyph && glyph.path && glyph.path.commands) {
                    // ãƒ‘ã‚¹ã‚³ãƒãƒ³ãƒ‰ã‚’æ‰‹å‹•ã§SVGãƒ‘ã‚¹ã«å¤‰æ›
                    let pathString = '';
                    
                    for (const cmd of glyph.path.commands) {
                        switch (cmd.type) {
                            case 'M':
                                pathString += `M${(cmd.x * scale + currentX).toFixed(2)},${(baselineY - cmd.y * scale).toFixed(2)}`;
                                break;
                            case 'L':
                                pathString += `L${(cmd.x * scale + currentX).toFixed(2)},${(baselineY - cmd.y * scale).toFixed(2)}`;
                                break;
                            case 'C':
                                pathString += `C${(cmd.x1 * scale + currentX).toFixed(2)},${(baselineY - cmd.y1 * scale).toFixed(2)} ${(cmd.x2 * scale + currentX).toFixed(2)},${(baselineY - cmd.y2 * scale).toFixed(2)} ${(cmd.x * scale + currentX).toFixed(2)},${(baselineY - cmd.y * scale).toFixed(2)}`;
                                break;
                            case 'Q':
                                pathString += `Q${(cmd.x1 * scale + currentX).toFixed(2)},${(baselineY - cmd.y1 * scale).toFixed(2)} ${(cmd.x * scale + currentX).toFixed(2)},${(baselineY - cmd.y * scale).toFixed(2)}`;
                                break;
                            case 'Z':
                                pathString += 'Z';
                                break;
                        }
                    }
                    
                    if (pathString && pathString !== 'Z') {
                        pathElements.push(`<path d="${pathString}" fill="${color}" fill-rule="evenodd"/>`);
                    }
                }
                
                // æ¬¡ã®æ–‡å­—ã®ä½ç½®ã‚’è¨ˆç®—ï¼ˆã‚«ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’è€ƒæ…®ï¼‰
                const advanceWidth = (glyph.advanceWidth || 0) * scale;
                const nextChar = text[i + 1];
                let kerning = 0;
                
                if (nextChar && loadedFont.getKerningValue) {
                    kerning = loadedFont.getKerningValue(glyph, loadedFont.charToGlyph(nextChar)) * scale;
                }
                
                currentX += advanceWidth + kerning;
            }

            // SVGã®å…¨ä½“ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
            const svgWidth = Math.max(currentX + 20, 200);
            const svgHeight = baselineY + fontSize * 0.3 + 20;

            // SVGã‚’æ§‹ç¯‰
            const svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" xmlns="http://www.w3.org/2000/svg">
  <rect width="100%" height="100%" fill="white"/>
  <g>
    ${pathElements.join('\n    ')}
  </g>
</svg>`;

            return svgContent;
        }

        function previewSVG() {
            try {
                const text = document.getElementById('outputText').value.trim();
                const fontSize = parseInt(document.getElementById('fontSize').value);
                const color = document.getElementById('fontColor').value;
                const precision = parseInt(document.getElementById('precision').value);
                
                if (!text) {
                    showStatus('å‡ºåŠ›ã™ã‚‹æ–‡å­—ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                if (!loadedFont) {
                    showStatus('ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„', 'error');
                    return;
                }

                const previewDiv = document.getElementById('preview');
                const previewContent = document.getElementById('previewContent');
                
                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ã«æœ€åˆã®æ•°æ–‡å­—ã®SVGã‚’ç”Ÿæˆ
                const previewText = text.slice(0, 10); // æœ€åˆã®10æ–‡å­—ã¾ã§
                let previewHtml = '<div style="display: flex; flex-wrap: wrap; gap: 10px;">';
                let totalSize = 0; // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã®æ¦‚ç®—è¨ˆç®—ç”¨
                
                for (let i = 0; i < previewText.length; i++) {
                    const char = previewText[i];
                    
                    if (char === '\n' || char === '\r' || char === '\t') {
                        continue;
                    }
                    
                    if (char === ' ') {
                        previewHtml += '<div style="border: 1px dashed #ccc; padding: 5px; min-width: 15px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 10px; color: #666;">SP</div>';
                        continue;
                    }
                    
                    try {
                        const svgContent = createSVGForSingleChar(char, fontSize, color, precision);
                        if (svgContent) {
                            totalSize += svgContent.length;
                            const codePoint = char.codePointAt(0);
                            const unicodeHex = codePoint.toString(16).toUpperCase().padStart(4, '0');
                            const fileSizeKB = (svgContent.length / 1024).toFixed(2);
                            
                            previewHtml += `
                                <div style="border: 1px solid #ddd; padding: 5px; text-align: center;">
                                    <div style="margin-bottom: 3px;">${svgContent}</div>
                                    <div style="font-size: 9px; color: #666;">"${char}"<br>U+${unicodeHex}<br>${fileSizeKB}KB</div>
                                </div>
                            `;
                        }
                    } catch (error) {
                        console.warn(`æ–‡å­— "${char}" ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”Ÿæˆã‚¨ãƒ©ãƒ¼:`, error);
                        previewHtml += `
                            <div style="border: 1px solid #f00; padding: 5px; text-align: center; color: red;">
                                <div style="font-size: 10px;">ã‚¨ãƒ©ãƒ¼</div>
                                <div style="font-size: 8px;">"${char}"</div>
                            </div>
                        `;
                    }
                }
                
                previewHtml += '</div>';
                
                // ã‚µã‚¤ã‚ºæƒ…å ±ã‚’è¡¨ç¤º
                const avgSize = totalSize / Math.max(previewText.replace(/[\n\r\t ]/g, '').length, 1);
                const estimatedTotal = avgSize * text.replace(/[\n\r\t ]/g, '').length;
                
                if (text.length > 10) {
                    previewHtml += `<div style="margin-top: 15px; padding: 10px; background: #f0f8ff; border-radius: 5px; font-size: 14px; color: #2c5aa0;">
                        <strong>ğŸ“Š ã‚µã‚¤ã‚ºæƒ…å ±</strong><br>
                        ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸­ã®æ–‡å­—: å¹³å‡ ${(avgSize / 1024).toFixed(2)}KB/æ–‡å­—<br>
                        å…¨ä½“æ¨å®šã‚µã‚¤ã‚º: ç´„ ${(estimatedTotal / 1024).toFixed(2)}KB<br>
                        ç²¾åº¦è¨­å®š: ${precision === 0 ? 'æ•´æ•°ã®ã¿ (æœ€è»½é‡)' : precision === 10 ? 'å°æ•°ç¬¬10ä½ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)' : `å°æ•°ç¬¬${precision}ä½`}<br>
                        â€» æœ€åˆã®10æ–‡å­—ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤ºä¸­ (å…¨${text.length}æ–‡å­—ãŒç”Ÿæˆå¯¾è±¡)
                    </div>`;
                } else {
                    previewHtml += `<div style="margin-top: 15px; padding: 10px; background: #f0f8ff; border-radius: 5px; font-size: 14px; color: #2c5aa0;">
                        <strong>ğŸ“Š ã‚µã‚¤ã‚ºæƒ…å ±</strong><br>
                        ç·ã‚µã‚¤ã‚º: ${(totalSize / 1024).toFixed(2)}KB<br>
                        å¹³å‡: ${(avgSize / 1024).toFixed(2)}KB/æ–‡å­—<br>
                        ç²¾åº¦è¨­å®š: ${precision === 0 ? 'æ•´æ•°ã®ã¿ (æœ€è»½é‡)' : precision === 10 ? 'å°æ•°ç¬¬10ä½ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)' : `å°æ•°ç¬¬${precision}ä½`}
                    </div>`;
                }
                
                previewContent.innerHTML = previewHtml;
                previewDiv.style.display = 'block';
                
                showStatus('æ–‡å­—åˆ¥ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ç”Ÿæˆã—ã¾ã—ãŸï¼ˆãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ï¼‰', 'success');
                
            } catch (error) {
                showStatus(`ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, 'error');
                console.error('Preview error:', error);
            }
        }

        async function generateZip() {
            try {
                const text = document.getElementById('outputText').value.trim();
                const filePrefix = document.getElementById('filePrefix').value.trim();
                const fontSize = parseInt(document.getElementById('fontSize').value);
                const color = document.getElementById('fontColor').value;
                const precision = parseInt(document.getElementById('precision').value);

                if (!text) {
                    showStatus('å‡ºåŠ›ã™ã‚‹æ–‡å­—ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                if (!loadedFont) {
                    showStatus('ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„', 'error');
                    return;
                }

                showStatus('æ–‡å­—ã”ã¨ã®SVGï¼ˆãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ï¼‰ã‚’ç”Ÿæˆä¸­...', 'info');

                const zip = new JSZip();
                let fileCount = 0;
                const charCounts = {}; // é‡è¤‡æ–‡å­—ã®ã‚«ã‚¦ãƒ³ãƒˆç”¨
                
                // æ–‡å­—ã‚’ä¸€æ–‡å­—ãšã¤å‡¦ç†
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    
                    // åˆ¶å¾¡æ–‡å­—ï¼ˆæ”¹è¡Œã€ã‚¿ãƒ–ã€ç©ºç™½ãªã©ï¼‰ã‚’ã‚¹ã‚­ãƒƒãƒ—
                    if (char === '\n' || char === '\r' || char === '\t') {
                        continue;
                    }
                    
                    try {
                        const svgContent = createSVGForSingleChar(char, fontSize, color, precision);
                        
                        if (svgContent) {
                            // å®‰å…¨ãªãƒ•ã‚¡ã‚¤ãƒ«åã‚’ä½œæˆ
                            // ç¦æ­¢æ–‡å­—ã‚’ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã«ç½®æ›ã—ã€URIã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚‚ä½¿ç”¨ã—ãªã„
                            let safeName = char.replace(/[\/\\?%*:|"<>]/g, '_');
                            // é‡è¤‡æ–‡å­—ã®ã‚«ã‚¦ãƒ³ãƒˆ
                            charCounts[safeName] = (charCounts[safeName] || 0) + 1;
                            
                            // ãƒ•ã‚¡ã‚¤ãƒ«åã®æ§‹æˆ: æ¥é ­è¾ + å®‰å…¨ãªæ–‡å­— + é‡è¤‡é€£ç•ª + æ‹¡å¼µå­
                            const countSuffix = charCounts[safeName] > 1 ? `_${charCounts[safeName]}` : '';
                            const fileName = `${filePrefix}${safeName}${countSuffix}.svg`;
                            zip.file(fileName, svgContent);
                            fileCount++;
                        }
                    } catch (charError) {
                        console.warn(`æ–‡å­— "${char}" ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼:`, charError);
                        // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸæ–‡å­—ã‚‚è¨˜éŒ²
                        const codePoint = char.codePointAt(0);
                        const unicodeHex = codePoint.toString(16).toUpperCase().padStart(4, '0');
                        
                        // ãƒ•ã‚©ãƒ³ãƒˆãƒ¡ãƒˆãƒªã‚¯ã‚¹ã«åŸºã¥ã„ãŸã‚¨ãƒ©ãƒ¼SVG
                        const scale = fontSize / loadedFont.unitsPerEm;
                        const ascender = (loadedFont.ascender || 0) * scale;
                        const descender = (loadedFont.descender || 0) * scale;
                        const lineHeight = ascender - descender;
                        const margin = 2;
                        const errorWidth = fontSize;
                        
                        const errorSvg = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${(errorWidth + margin * 2).toFixed(2)}" height="${(lineHeight + margin * 2).toFixed(2)}" viewBox="0 0 ${(errorWidth + margin * 2).toFixed(2)} ${(lineHeight + margin * 2).toFixed(2)}" xmlns="http://www.w3.org/2000/svg">
  <!-- ã‚¨ãƒ©ãƒ¼æ–‡å­—: "${char}" U+${unicodeHex} -->
  <rect x="${margin}" y="${margin}" width="${errorWidth}" height="${lineHeight}" fill="none" stroke="red" stroke-width="1"/>
  <path d="M${margin + errorWidth * 0.2},${margin + lineHeight * 0.8} L${margin + errorWidth * 0.8},${margin + lineHeight * 0.2} M${margin + errorWidth * 0.2},${margin + lineHeight * 0.2} L${margin + errorWidth * 0.8},${margin + lineHeight * 0.8}" stroke="red" stroke-width="1"/>
</svg>`;
                        
                        charCounts['error'] = (charCounts['error'] || 0) + 1;
                        const fileName = `${filePrefix}ERROR_${charCounts['error']}_U${unicodeHex}.svg`;
                        zip.file(fileName, errorSvg);
                        fileCount++;
                    }
                }

                if (fileCount === 0) {
                    showStatus('ç”Ÿæˆå¯èƒ½ãªæ–‡å­—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ', 'error');
                    return;
                }

                // ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(zipBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `font_svg_chars_${new Date().getTime()}.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                URL.revokeObjectURL(url);
                
                showStatus(`${fileCount}å€‹ã®æ–‡å­—åˆ¥SVGãƒ•ã‚¡ã‚¤ãƒ«ã®ZIPãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸ`, 'success');
                
            } catch (error) {
                showStatus(`ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, 'error');
                console.error('ZIP generation error:', error);
            }
        }
    </script>
</body>
</html>
